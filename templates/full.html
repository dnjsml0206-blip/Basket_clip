<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>êµì°¨ í¸ì§‘</title>

    <style>
        body {
            background: #121212;
            color: #fff;
            font-family: sans-serif;
            padding: 20px;
        }

        h2 { margin-top: 0; }

        /* --------- ë©”ì¸ í”„ë¦¬ë·° ì˜ì—­ --------- */
        #previewCanvas {
            width: 100%;
            max-height: 420px;
            background: #000;
            border-radius: 8px;
        }

        .control-bar {
            margin-top: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #playPauseBtn {
            padding: 6px 14px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            background: #0af;
            color: #000;
            font-size: 14px;
        }

        #timeLabel {
            font-size: 13px;
            color: #ccc;
            min-width: 90px;
        }

        #seekSlider {
            flex: 1;
        }

        /* --------- íƒ€ì„ë¼ì¸ UI --------- */
        .timeline-box {
            margin-top: 20px;
        }

        .timeline-label {
            font-size: 13px;
            margin-bottom: 4px;
            color: #ccc;
        }

        #timelineWrapper {
            width: 100%;
            overflow-x: auto;
            overflow-y: hidden;
            padding-bottom: 10px;
        }

        .timeline {
            width: 3000px;   /* ìŠ¤í¬ë¡¤ ìƒê¸°ë„ë¡ ê°€ë¡œë¡œ ê¸¸ê²Œ */
            height: 20px;
            background: #666;
            margin-top: 10px;
            position: relative;
            border-radius: 4px;
            cursor: pointer;
        }

        .selection-box {
            position: absolute;
            top: 0;
            height: 100%;
            background: rgba(0,150,255,0.25);
            border: 1px solid #09f;
            pointer-events: none;
        }

        .segment {
            position: absolute;
            top: 0;
            height: 100%;
            background: rgba(0, 200, 255, 0.4);
            border: 1px solid #00e1ff;
            cursor: move;
            box-sizing: border-box;
        }

        .segment.selected {
            background: rgba(255, 220, 0, 0.55);
            border: 2px solid yellow;
        }

        .handle {
            position: absolute;
            top: 0;
            width: 6px;
            height: 100%;
            background: rgba(255,255,255,0.8);
            cursor: ew-resize;
        }

        .handle.left  { left: 0; }
        .handle.right { right: 0; }

        /* --------- Ruler --------- */
        .ruler {
            margin-top: 8px;
            height: 20px;
            position: relative;
            font-size: 10px;
            color: #aaa;
        }

        .tick {
            position: absolute;
            top: 0;
            height: 8px;
            width: 1px;
            background: #aaa;
        }

        .tick-label {
            position: absolute;
            top: 10px;
            font-size: 10px;
            transform: translateX(-50%);
        }

        /* --------- ë²„íŠ¼ --------- */
        .btn-box {
            margin-top: 20px;
        }

        button {
            padding: 8px 14px;
            margin-right: 8px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-size: 14px;
        }

        .play-btn   { background: #0af;   color: #000; }
        .export-btn { background:#0f0;   color:#000; }
        .del-btn    { background: #ff4444; color: #000; }

        .hint {
            margin-top:10px;
            font-size:12px;
            color:#aaa;
            line-height: 1.5;
        }
    </style>
</head>

<body>

<h2>ğŸ¬ ì¢Œ/ìš° ê³¨ëŒ€ êµì°¨ í¸ì§‘</h2>

<!-- ì‹¤ì œ ì¬ìƒ ì†ŒìŠ¤ (ìˆ¨ê¹€, ì˜¤ë””ì˜¤ëŠ” left ë§Œ ì‚¬ìš©) -->
<video id="leftVideo"  src="/full_file?p={{ left_src }}"></video>
<video id="rightVideo" src="/full_file?p={{ right_src }}" muted></video>

<!-- ë‘ ì˜ìƒì„ ê²¹ì³ì„œ ë³´ì—¬ì¤„ Canvas -->
<canvas id="previewCanvas" width="1280" height="720"></canvas>

<!-- ì»¤ìŠ¤í…€ ì¬ìƒ/ì¼ì‹œì •ì§€ + Seek ë°” -->
<div class="control-bar">
    <button id="playPauseBtn" class="play-btn">â–¶ ì¬ìƒ</button>
    <span id="timeLabel">00:00 / 00:00</span>
    <input type="range" id="seekSlider" min="0" max="1000" value="0">
</div>

<!-- íƒ€ì„ë¼ì¸ (ì¢Œ/ìš°) -->
<div id="timelineWrapper">
    <div class="timeline-box">
        <div class="timeline-label">ì¢Œì¸¡ ì¹´ë©”ë¼</div>
        <div id="timelineLeft" class="timeline"></div>
    </div>

    <div class="timeline-box">
        <div class="timeline-label">ìš°ì¸¡ ì¹´ë©”ë¼</div>
        <div id="timelineRight" class="timeline"></div>
    </div>
</div>

<!-- ê³µí†µ ruler -->
<div id="ruler" class="ruler"></div>

<div class="btn-box">
    <button id="addSegmentBtn">êµ¬ê°„ ì¶”ê°€</button>
    <button class="del-btn" onclick="deleteSegment()">ì„ íƒ êµ¬ê°„ ì‚­ì œ</button>
    <button onclick="saveEdit()">ì‘ì—… ì €ì¥</button>
    <button onclick="loadEdit()">ì‘ì—… ë¶ˆëŸ¬ì˜¤ê¸°</button>
    <button class="export-btn" onclick="exportVideo()">ì˜ìƒ ì¶”ì¶œ</button>
</div>

<div class="hint">
    â€¢ ìƒë‹¨ ì˜ìƒì€ ì¢Œ/ìš° ì˜ìƒì„ ê²¹ì³ì„œ ë³´ì—¬ì¤ë‹ˆë‹¤. ì¬ìƒ ì‹œ, <b>segment ì„¤ì •ì— ë”°ë¼ ì¹´ë©”ë¼ê°€ ìë™ ì „í™˜</b>ë©ë‹ˆë‹¤.<br>
    â€¢ íƒ€ì„ë¼ì¸ ë¹ˆ ê³³ í´ë¦­ â†’ í•´ë‹¹ ì¹´ë©”ë¼/ì‹œê°„ìœ¼ë¡œ ì‹œì  ì´ë™ (pause ìƒíƒœ).<br>
    â€¢ êµ¬ê°„(ìƒ‰ ë§‰ëŒ€) í´ë¦­ â†’ ì„ íƒ / Shift+í´ë¦­ â†’ ë‹¤ì¤‘ ì„ íƒ, Delete í‚¤ ë˜ëŠ” "ì„ íƒ êµ¬ê°„ ì‚­ì œ"ë¡œ ì œê±°.<br>
    â€¢ êµ¬ê°„ ë”ë¸”í´ë¦­ â†’ í•´ë‹¹ êµ¬ê°„ ì‹œì‘ ì§€ì ì—ì„œ ì¬ìƒ.<br>
    â€¢ êµ¬ê°„ì€ ë“œë˜ê·¸ë¡œ ì´ë™, ì–‘ ë í° ë§‰ëŒ€ë¡œ ê¸¸ì´ ì¡°ì ˆ. ì¢Œ/ìš° íƒ€ì„ë¼ì¸ ê°„ì—ëŠ” ì‹œê°„ì´ ì„œë¡œ ê²¹ì¹˜ì§€ ì•Šë„ë¡ ë§‰ìŠµë‹ˆë‹¤.
</div>

<script>
/* ======================= í…œí”Œë¦¿ ë°ì´í„° ======================= */
const sessionId      = "{{ session_id }}";
const duration       = Number({{ duration }});   // ì „ì²´ ê¸¸ì´(ì´ˆ)
const leftSrcPath    = "{{ left_src }}";
const rightSrcPath   = "{{ right_src }}";
const leftVideoName  = "{{ left_video }}";
const rightVideoName = "{{ right_video }}";
const offset         = Number({{ offset }});     // ğŸ”´ ì‹±í¬ ì˜¤í”„ì…‹ (ì´ˆ, right ê¸°ì¤€)

/* ì„¸ê·¸ë¨¼íŠ¸ ë°ì´í„° */
let leftClips  = {{ left_clips  | tojson }};
let rightClips = {{ right_clips | tojson }};

let segments = [];
leftClips.forEach(c  => segments.push({ start: c.start, end: c.end, side: "left"  }));
rightClips.forEach(c => segments.push({ start: c.start, end: c.end, side: "right" }));

let selected = null;
let selectedSegments = new Set();
let lastClickedSide = "left";
let previewOverrideSide = null;

/* ì¬ìƒ ê´€ë ¨ */
const leftVideo  = document.getElementById("leftVideo");
const rightVideo = document.getElementById("rightVideo");
const canvas     = document.getElementById("previewCanvas");
const ctx        = canvas.getContext("2d");

const tlLeft  = document.getElementById("timelineLeft");
const tlRight = document.getElementById("timelineRight");
const playBtn = document.getElementById("playPauseBtn");
const seek    = document.getElementById("seekSlider");
const timeLbl = document.getElementById("timeLabel");

let currentTime = 0;
let playing     = false;


/* ======================= 1) RULER ======================= */
function buildRuler() {
    const r = document.getElementById("ruler");
    r.innerHTML = "";

    const step = duration <= 60 ? 5 : 10;
    for (let t = 0; t <= duration; t += step) {
        const x = (t / duration) * 100;

        const tick = document.createElement("div");
        tick.className = "tick";
        tick.style.left = x + "%";
        r.appendChild(tick);

        const label = document.createElement("div");
        label.className = "tick-label";
        label.style.left = x + "%";
        label.innerText = `${t}s`;
        r.appendChild(label);
    }
}


/* ======================= 2) ì¹´ë©”ë¼ ì„ íƒ ë¡œì§ ======================= */
function getCameraForTime(t) {
    // ì¬ìƒ ì¤‘ì´ ì•„ë‹ˆê³ , í”„ë¦¬ë·° ì˜¤ë²„ë¼ì´ë“œê°€ ìˆìœ¼ë©´ ìš°ì„ 
    if (!playing && previewOverrideSide) {
        return previewOverrideSide;
    }

    // segments ì—ì„œ í•´ë‹¹ ì‹œê°„ì— í¬í•¨ë˜ëŠ” ë§ˆì§€ë§‰ segment ì˜ side ì‚¬ìš©
    let cam = "left";
    for (const seg of segments) {
        if (t >= seg.start && t < seg.end) {
            cam = seg.side;
        }
    }
    return cam;
}


/* ======================= 3) ì˜¤ë²„ë© ì²´í¬ (ì¢Œ/ìš° ê°„ë§Œ) ======================= */
function hasOverlap(start, end, side) {
    return segments.some(seg => {
        if (seg.side === side) return false;
        // ë‹¤ë¥¸ side ì™€ ì‹œê°„ ê²¹ì¹¨?
        return !(seg.end <= start || seg.start >= end);
    });
}


/* ======================= 4) íƒ€ì„ë¼ì¸ ë Œë” ======================= */
function renderTimeline() {
    tlLeft.innerHTML  = "";
    tlRight.innerHTML = "";

    const pxLeft  = tlLeft.clientWidth  || 1;
    const pxRight = tlRight.clientWidth || 1;

    segments.forEach((seg, idx) => {
        const tl      = (seg.side === "left") ? tlLeft : tlRight;
        const tlWidth = (seg.side === "left") ? pxLeft : pxRight;

        const box = document.createElement("div");
        box.className = "segment";
        if (selected === idx || selectedSegments.has(idx)) {
            box.classList.add("selected");
        }

        const left = (seg.start / duration) * 100;
        const width = ((seg.end - seg.start) / duration) * 100;
        box.style.left  = left + "%";
        box.style.width = width + "%";

        // ë‹¨ì¼ í´ë¦­ â†’ ì„ íƒ + ì‹œì  ì´ë™ (pause)
        box.addEventListener("click", (e) => {
            e.stopPropagation();
            lastClickedSide = seg.side;

            if (e.shiftKey) {
                if (selectedSegments.has(idx)) selectedSegments.delete(idx);
                else selectedSegments.add(idx);
            } else {
                selected = idx;
                selectedSegments.clear();
                selectedSegments.add(idx);
            }

            currentTime = seg.start;
            previewOverrideSide = seg.side;
            syncVideosToCurrentTime();
            playing = false;
            updatePlayButton();
            updateSeekUI();
            renderTimeline();
        });

        // ë”ë¸” í´ë¦­ â†’ í•´ë‹¹ êµ¬ê°„ ì‹œì‘ì—ì„œ ì¬ìƒ
        box.ondblclick = (e) => {
            e.stopPropagation();
            currentTime = seg.start;
            previewOverrideSide = null; // ì¬ìƒ ì‹œì—ëŠ” segments ê¸°ì¤€
            syncVideosToCurrentTime();
            playing = true;
            playVideos();
            updatePlayButton();
        };

        // ---- ë“œë˜ê·¸ë¡œ ì „ì²´ ì´ë™ ----
        box.onmousedown = (e) => {
            if (e.target.classList.contains("handle")) return;

            e.preventDefault();
            const startX    = e.clientX;
            const initStart = seg.start;
            const initEnd   = seg.end;

            const move = (e2) => {
                const dx = e2.clientX - startX;
                const px = tlWidth;
                const dt = (dx / px) * duration;

                let newStart = initStart + dt;
                let newEnd   = initEnd + dt;

                if (newStart < 0) {
                    newEnd -= newStart;
                    newStart = 0;
                }
                if (newEnd > duration) {
                    const diff = newEnd - duration;
                    newStart -= diff;
                    newEnd   = duration;
                }

                if (hasOverlap(newStart, newEnd, seg.side)) return;

                seg.start = newStart;
                seg.end   = newEnd;

                currentTime = seg.start;
                previewOverrideSide = seg.side;
                syncVideosToCurrentTime();
                updateSeekUI();

                renderTimeline();
            };

            const up = () => {
                document.removeEventListener("mousemove", move);
                document.removeEventListener("mouseup", up);
            };

            document.addEventListener("mousemove", move);
            document.addEventListener("mouseup", up);
        };

        // ---- ì–‘ ë í•¸ë“¤: ê¸¸ì´ì¡°ì ˆ ----
        const hLeft = document.createElement("div");
        hLeft.className = "handle left";
        hLeft.onmousedown = (e) => {
            e.stopPropagation();
            e.preventDefault();
            const startX    = e.clientX;
            const initStart = seg.start;

            const move = (e2) => {
                const dx = e2.clientX - startX;
                const px = tlWidth;
                const dt = (dx / px) * duration;

                let newStart = initStart + dt;
                if (newStart < 0) newStart = 0;
                if (newStart > seg.end - 0.5) newStart = seg.end - 0.5;

                if (hasOverlap(newStart, seg.end, seg.side)) return;

                seg.start = newStart;

                currentTime = seg.start;
                previewOverrideSide = seg.side;
                syncVideosToCurrentTime();
                updateSeekUI();

                renderTimeline();
            };

            const up = () => {
                document.removeEventListener("mousemove", move);
                document.removeEventListener("mouseup", up);
            };
            document.addEventListener("mousemove", move);
            document.addEventListener("mouseup", up);
        };

        const hRight = document.createElement("div");
        hRight.className = "handle right";
        hRight.onmousedown = (e) => {
            e.stopPropagation();
            e.preventDefault();
            const startX  = e.clientX;
            const initEnd = seg.end;

            const move = (e2) => {
                const dx = e2.clientX - startX;
                const px = tlWidth;
                const dt = (dx / px) * duration;

                let newEnd = initEnd + dt;
                if (newEnd > duration) newEnd = duration;
                if (newEnd < seg.start + 0.5) newEnd = seg.start + 0.5;

                if (hasOverlap(seg.start, newEnd, seg.side)) return;

                seg.end = newEnd;

                currentTime = seg.start;
                previewOverrideSide = seg.side;
                syncVideosToCurrentTime();
                updateSeekUI();

                renderTimeline();
            };

            const up = () => {
                document.removeEventListener("mousemove", move);
                document.removeEventListener("mouseup", up);
            };
            document.addEventListener("mousemove", move);
            document.addEventListener("mouseup", up);
        };

        box.appendChild(hLeft);
        box.appendChild(hRight);
        tl.appendChild(box);
    });
}


/* ======================= 5) ë“œë˜ê·¸ ì„ íƒ ë°•ìŠ¤ (ë‹¤ì¤‘ ì„ íƒ) ======================= */
let isDraggingSelection = false;
let dragStartX = 0;
let selectionDiv = null;

function attachSelectionDrag(timeline) {
    timeline.addEventListener("mousedown", (e) => {
        if (e.target.classList.contains("segment") || e.target.classList.contains("handle")) return;

        isDraggingSelection = true;
        const rect = timeline.getBoundingClientRect();
        dragStartX = e.clientX;

        if (selectionDiv) {
            selectionDiv.remove();
            selectionDiv = null;
        }

        selectionDiv = document.createElement("div");
        selectionDiv.className = "selection-box";
        selectionDiv.style.left = (e.clientX - rect.left) + "px";
        selectionDiv.style.width = "0px";
        timeline.appendChild(selectionDiv);
    });

    document.addEventListener("mousemove", (e) => {
        if (!isDraggingSelection || !selectionDiv) return;

        const rect = timeline.getBoundingClientRect();
        const x1   = dragStartX - rect.left;
        const x2   = e.clientX - rect.left;

        const left = Math.min(x1, x2);
        const width = Math.abs(x2 - x1);

        selectionDiv.style.left  = left + "px";
        selectionDiv.style.width = width + "px";
    });

    document.addEventListener("mouseup", (e) => {
        if (!isDraggingSelection || !selectionDiv) return;
        isDraggingSelection = false;

        const rect = timeline.getBoundingClientRect();
        const x1   = dragStartX - rect.left;
        const x2   = e.clientX   - rect.left;

        const pxStart = Math.min(x1, x2);
        const pxEnd   = Math.max(x1, x2);

        const tStart = (pxStart / rect.width) * duration;
        const tEnd   = (pxEnd   / rect.width) * duration;

        selectionDiv.remove();
        selectionDiv = null;

        selectedSegments.clear();
        segments.forEach((seg, idx) => {
            const overlap = !(seg.end < tStart || seg.start > tEnd);
            if (overlap) {
                selectedSegments.add(idx);
            }
        });

        renderTimeline();
    });
}


/* ======================= 6) ë¹ˆ ê³µê°„ í´ë¦­ â†’ ì‹œì  ì´ë™ (pause) ======================= */
function attachTimelineClick() {
    tlLeft.addEventListener("click", (e) => {
        if (e.target.classList.contains("segment") || e.target.classList.contains("handle")) return;

        const rect  = tlLeft.getBoundingClientRect();
        const ratio = (e.clientX - rect.left) / rect.width;
        let t = ratio * duration;
        t = Math.max(0, Math.min(duration, t));

        lastClickedSide = "left";
        previewOverrideSide = "left";

        selected = null;
        selectedSegments.clear();
        renderTimeline();

        currentTime = t;
        syncVideosToCurrentTime();
        playing = false;
        updatePlayButton();
        updateSeekUI();
    });

    tlRight.addEventListener("click", (e) => {
        if (e.target.classList.contains("segment") || e.target.classList.contains("handle")) return;

        const rect  = tlRight.getBoundingClientRect();
        const ratio = (e.clientX - rect.left) / rect.width;
        let t = ratio * duration;
        t = Math.max(0, Math.min(duration, t));

        lastClickedSide = "right";
        previewOverrideSide = "right";

        selected = null;
        selectedSegments.clear();
        renderTimeline();

        currentTime = t;
        syncVideosToCurrentTime();
        playing = false;
        updatePlayButton();
        updateSeekUI();
    });
}


/* ======================= 7) êµ¬ê°„ ì¶”ê°€ / ì‚­ì œ ======================= */
function addSegment() {
    let t = currentTime;

    let start = t;
    let end   = t + 2.0;

    if (end > duration) {
        end   = duration;
        start = Math.max(0, end - 2.0);
    }

    const side = lastClickedSide || "left";

    if (hasOverlap(start, end, side)) {
        alert("ë‹¤ë¥¸ ì¹´ë©”ë¼ êµ¬ê°„ê³¼ ì‹œê°„ì´ ê²¹ì³ì„œ ì¶”ê°€í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
        return;
    }

    segments.push({ start, end, side });
    selected = segments.length - 1;
    selectedSegments.clear();
    selectedSegments.add(selected);

    renderTimeline();
}

function deleteSegment() {
    if (selectedSegments.size > 0) {
        segments = segments.filter((seg, idx) => !selectedSegments.has(idx));
        selectedSegments.clear();
        selected = null;
        renderTimeline();
    } else if (selected != null) {
        segments.splice(selected, 1);
        selected = null;
        renderTimeline();
    } else {
        alert("ì‚­ì œí•  êµ¬ê°„ì´ ì„ íƒë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤.");
    }
}


/* ======================= 8) ì¬ìƒ/íƒ€ì„ë¼ì¸ UI ======================= */
function formatTime(sec) {
    if (!isFinite(sec)) sec = 0;
    const m = Math.floor(sec / 60);
    const s = Math.floor(sec % 60);
    return String(m).padStart(2,"0") + ":" + String(s).padStart(2,"0");
}

function updateSeekUI() {
    if (!duration || !isFinite(duration) || duration <= 0) {
        seek.value = 0;
        timeLbl.textContent = "00:00 / 00:00";
        return;
    }

    const ratio = currentTime / duration;
    seek.value = Math.max(0, Math.min(1000, Math.floor(ratio * 1000)));
    timeLbl.textContent = `${formatTime(currentTime)} / ${formatTime(duration)}`;
}

function updatePlayButton() {
    playBtn.textContent = playing ? "â¸ ì¼ì‹œì •ì§€" : "â–¶ ì¬ìƒ";
}

/* ğŸ”´ ì˜¤í”„ì…‹ì„ ë°˜ì˜í•´ì„œ ì˜¤ë¥¸ìª½ ì˜ìƒ ì‹±í¬ ë§ì¶”ê¸° */
function syncVideosToCurrentTime() {
    leftVideo.currentTime = currentTime;
    let rt = currentTime - offset;
    if (rt < 0) rt = 0;
    if (rightVideo.duration && rt > rightVideo.duration) rt = rightVideo.duration;
    rightVideo.currentTime = rt;
}

function playVideos() {
    leftVideo.play().catch(()=>{});
    rightVideo.play().catch(()=>{});
}

function pauseVideos() {
    leftVideo.pause();
    rightVideo.pause();
}

function togglePlay() {
    if (!duration || duration <= 0) return;

    if (playing) {
        playing = false;
        pauseVideos();
    } else {
        playing = true;
        previewOverrideSide = null; // ì¬ìƒ ì¤‘ì—ëŠ” segments ê¸°ì¤€
        syncVideosToCurrentTime();
        playVideos();
    }
    updatePlayButton();
}

/* Seek ë°” ë“œë˜ê·¸ */
seek.addEventListener("input", (e) => {
    const val   = Number(e.target.value);
    const ratio = val / 1000;
    currentTime = duration * ratio;
    syncVideosToCurrentTime();
    updateSeekUI();
});

seek.addEventListener("change", () => {
    if (!playing) {
        pauseVideos();
    }
});


/* ======================= 9) Canvas ë Œë” ë£¨í”„ ======================= */
function drawFrame(cam) {
    const w = canvas.width;
    const h = canvas.height;
    ctx.clearRect(0, 0, w, h);

    try {
        // ê¸°ë³¸ì€ left ì „ì²´ ê·¸ë¦¬ê¸°
        ctx.drawImage(leftVideo, 0, 0, w, h);
    } catch(e) {}

    if (cam === "right") {
        try {
            ctx.drawImage(rightVideo, 0, 0, w, h);
        } catch(e) {}
    }
}

function startRenderLoop() {
    function loop() {
        if (playing) {
            currentTime = leftVideo.currentTime;

            if (currentTime >= duration) {
                currentTime = duration;
                playing = false;
                pauseVideos();
                updatePlayButton();
            } else {
                // ğŸ”´ ì¬ìƒ ì¤‘ì—ë„ offset ë°˜ì˜í•´ì„œ right ì‹±í¬ ìœ ì§€
                let rtime = currentTime - offset;
                if (rtime < 0) rtime = 0;
                if (rightVideo.duration && rtime > rightVideo.duration) {
                    rtime = rightVideo.duration;
                }
                rightVideo.currentTime = rtime;
            }
        }

        const cam = getCameraForTime(currentTime);
        drawFrame(cam);
        updateSeekUI();

        requestAnimationFrame(loop);
    }
    loop();
}


/* ======================= 10) ì‘ì—… ì €ì¥ / ë¶ˆëŸ¬ì˜¤ê¸° / ì¶”ì¶œ ======================= */
async function saveEdit() {
    if (!segments.length) {
        if (!confirm("ì €ì¥í•  êµ¬ê°„ì´ ì—†ìŠµë‹ˆë‹¤. ê·¸ë˜ë„ ì €ì¥í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) return;
    }

    const payload = {
        left_video:  leftVideoName,
        right_video: rightVideoName,
        segments:    segments
    };

    const res  = await fetch("/full_save_edit", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify(payload)
    });
    const data = await res.json();

    if (data.ok) {
        alert("ì‘ì—…ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.");
    } else {
        alert("ì‘ì—… ì €ì¥ ì‹¤íŒ¨: " + (data.error || "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜"));
    }
}

async function loadEdit() {
    const url = `/full_load_edit?left=${encodeURIComponent(leftVideoName)}&right=${encodeURIComponent(rightVideoName)}`;
    const res  = await fetch(url);
    const data = await res.json();

    if (!data.ok) {
        alert("ì‘ì—… ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨: " + (data.error || "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜"));
        return;
    }

    if (!data.segments || !data.segments.length) {
        alert("ì €ì¥ëœ ì‘ì—…ì´ ì—†ìŠµë‹ˆë‹¤.");
        return;
    }

    segments = data.segments;
    selected = null;
    selectedSegments.clear();
    renderTimeline();
    alert("ì €ì¥ëœ ì‘ì—…ì„ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.");
}

async function exportVideo() {
    if (segments.length === 0) {
        alert("ì¶”ì¶œí•  êµ¬ê°„ì´ ì—†ìŠµë‹ˆë‹¤.");
        return;
    }

    const ordered = [...segments].sort((a,b) => a.start - b.start);

    const payload = {
        session_id: sessionId,
        left_video:  leftVideoName,
        right_video: rightVideoName,
        left_src:    leftSrcPath,
        right_src:   rightSrcPath,
        segments:    ordered
    };

    const res  = await fetch("/full_export", {
        method:  "POST",
        headers: {"Content-Type": "application/json"},
        body:    JSON.stringify(payload)
    });
    const data = await res.json();

    if (!data.ok) {
        alert("ì˜ìƒ ì¶”ì¶œ ì¤‘ ì˜¤ë¥˜: " + (data.error || "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜"));
        return;
    }

    window.location.href = "/full_result?file=" + encodeURIComponent(data.file);
}


/* ======================= 11) ì´ˆê¸° ì„¤ì • ======================= */
buildRuler();
renderTimeline();
attachSelectionDrag(tlLeft);
attachSelectionDrag(tlRight);
attachTimelineClick();

document.getElementById("addSegmentBtn").onclick = addSegment;
playBtn.onclick = togglePlay;

// Delete / Backspace ë¡œ ì‚­ì œ
document.addEventListener("keydown", e => {
    if (e.key === "Delete" || e.key === "Del" || e.key === "Backspace") {
        deleteSegment();
    }
});

// ë¹„ë””ì˜¤ ë©”íƒ€ë°ì´í„° ë¡œë”© ì™„ë£Œ í›„ ë Œë” ë£¨í”„ ì‹œì‘
let metaLoaded = 0;
function onMetaLoaded() {
    metaLoaded++;
    if (metaLoaded >= 2) {
        currentTime = 0;
        syncVideosToCurrentTime();
        updateSeekUI();
        startRenderLoop();
    }
}
leftVideo.addEventListener("loadedmetadata", onMetaLoaded);
rightVideo.addEventListener("loadedmetadata", onMetaLoaded);
</script>

</body>
</html>
